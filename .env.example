# REMEMBER to keep variable names in sync with the Dockerfile so docker-compose can substitute them.

# --- PATHS ---
# The main config dir path
BASE_CONF_PATH=./config

# The SSL certs dir path. 
# Remember: the server.crt and server.key files must be placed in this directory.
CERTS_PATH=./config/certs/

# The template file is similar to a standard NGINX config but contains variables.
# Docker will replace the variables with values from the .env file when building the image.
CONF_TEMPLATE_PATH_REVERSE_PROXY=./config/nginx/conf.d/reverse-proxy.template.conf

# The volume path for the logs. It will contain both access and error logs.
LOGS_PATH=./logs/reverse-proxy

# The main NGINX configuration template (top-level nginx.conf). Use a template file
# with variables that will be replaced from this .env when building the image.
# Provide either a relative or absolute path (e.g., ./config/nginx/nginx.template.conf).
CONF_TEMPLATE_PATH_MAIN_CONFIG=./config/nginx/nginx.template.conf

# The common proxy directives for the backend and frontend.
PROXY_PARAMS_PATH=./config/nginx/conf.d/proxy_params.template.conf

# --- NETWORK ---
# If the Docker host also runs other services like Tomcat (which is intended), remember to create
# a common network for them. You can use the init-global-network.sh script for that.
# It is important to create the network BEFORE creating any services.
GLOBAL_NETWORK=global_network

# --- BACKEND (DSPACE/TOMCAT) ---
# If Tomcat is running on the same Docker network,
# the value should be the service name defined in the docker-compose file.
DSPACE_DSPACE_TOMCAT_HOST=dspace-backend-tomcat

# The port on which Tomcat is listening (default is 8080).
DSPACE_DSPACE_TOMCAT_PORT=8080

# --- FRONTEND ---
# If the frontend is running on the same Docker network,
# the value should be the service name defined in the docker-compose file.
DSPACE_UI_HOST=dspace-frontend

# The port on which the frontend is listening (default is 4000).
DSPACE_UI_PORT=4000

# --- NGINX CONFIG ---
# Maximum size of the request body that will be accepted by the server.
# The default is 1M. (I suggest increasing it to 512M as a standard.) 
# Remember to provide the correct unit (e.g., 1M, 1G, 1T) or use the number of bytes.
MAX_BODY_SIZE_BACKEND=512M
MAX_BODY_SIZE_FRONTEND=10M

# The number of retries before the backend is considered failed.
# The default is 3.
MAX_FAILS=4

# The time in seconds to wait before retrying the backend.
# The default is 30s.
FAIL_TIMEOUT=35s

# Max number of idle connections kept open to the backend.
KEEP_ALIVE=32

# --- TIMEOUTS ---
# Timeouts for the proxy connection.
# Important for DSpace heavy operations (e.g. large file uploads, imports).
# Default Nginx value is usually 60s.
PROXY_READ_TIMEOUT=90s
PROXY_CONNECT_TIMEOUT=90s
PROXY_SEND_TIMEOUT=90s

# --- SERVER INFO ---
# The domain name of the server. 
# You can use localhost.
NGINX_HOST_DOMAIN=localhost

# The actual server name of the project. 
# If we are hosting it - add our company prefix. If not - just use the project name.
PROJECT_NAME=NGINX_REVERSE_PROXY

# The timezone of the server. If hosted in Poland, use Europe/Warsaw.
TIMEZONE=Europe/Warsaw

# --- WORKERS ---
# Workers are the processes that handle incoming requests.
# The default rule is: 1 worker per 1 CPU core.

# Worker Math:
# Total Concurrency = Workers Count * Worker Connections Limit

# The number of simultaneous connections that can be handled by a single worker process.
# Default: 1024. Production recommendation: 4096.
# REMEMBER: Nginx as a reverse proxy uses TWO connections per single request:
# one connected to the client (browser) and one connected to the backend (DSpace).
WORKER_CONNECTIONS=4096

# The limit of open file descriptors per worker process.
# Since in Linux "everything is a file" (sockets, logs, static files), this limit
# must be significantly larger than WORKER_CONNECTIONS.
# Standard recommendation: WORKER_CONNECTIONS * 2.
WORKER_RLIMIT_NOFILE=8192